\documentclass[b5paper,11pt]{book}

\usepackage{geometry} 					% поля страницы

\usepackage{cmap}                       % Поддержка поиска русских слов в PDF (pdflatex)
\usepackage[T2A]{fontenc}				% Поддержка русских букв
\usepackage[utf8]{inputenc}            	% Выбор языка и кодировки
\usepackage[english, russian]{babel}	% Языки: русский, английский

\usepackage[unicode]{hyperref}			% Русский язык для оглавления pdf
\usepackage{bookmark}					% Оглавление в pdf
\usepackage{graphicx} 					% Подключаем пакет работы с графикой

\usepackage{amsmath,amssymb}

\usepackage{float}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\graphicspath{{../../images/textbooks/}} 			% Пути к изображениям

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}	% Геомтерия страницы

\usepackage[
%	autolang=hyphen,
language=auto,
autolang=other,
backend=biber,
style=gost-numeric
]{biblatex}
\addbibresource{slabai.bib}

\DeclareSourcemap{
	\maps[datatype=bibtex, overwrite]{
		\map{
			\step[fieldset=langid, fieldvalue=english]
			\step[fieldset=doi, null]
			\step[fieldset=issn, null]
			\step[fieldset=isbn, null]
			\step[fieldset=url, null]
			\step[fieldsource=language, fieldset=langid, origfieldval]
		}
	}
}

\newtheorem{Def}{Определение}
\newtheorem{Th}{Теорема}
\newtheorem{St}{Утверждение}

\numberwithin{Def}{section}
\numberwithin{Th}{chapter}
\numberwithin{St}{chapter}

\floatname{algorithm}{Алгоритм}
\algrenewcommand\algorithmicrequire{\textbf{Вход:}}
\algrenewcommand\algorithmicensure{\textbf{Выход:}}
\algrenewcommand\algorithmicforall{\textbf{для всех}}
\algrenewcommand\algorithmicwhile{\textbf{пока}}
\algrenewcommand\algorithmicif{\textbf{если}}
\algrenewcommand\algorithmicthen{\textbf{то}}
\algrenewcommand\algorithmicelse{\textbf{иначе}}
\algrenewcommand\algorithmicreturn{\textbf{вернуть}}
\algrenewcommand\algorithmicfunction{\textbf{функция}}
\algrenewcommand\algorithmicdo{}
\renewcommand{\algorithmiccomment}[1]{{\quad\sl // #1}}

\let\cleardoublepage\clearpage

\begin{document}
	 
	
	\chapter*{Планирование в пространстве состояний}
	
	Первым планировщиком, осуществляющим планирование в пространстве состояний, является STRIPS (STanford Research Institute Problem Solver). STRIPS изначально разрабатывался для решения задачи формирования плана поведения робота, перемещающего предметы через множество помещений.
	
	Собственно, идея алгоритма STRIPS заимствована из системы GPS \cite{Fikes1971}. Метод, использованный в GPS, назывался анализ средств и целей (means-ends analysis). Он подразумевает рассмотрение в текущем состоянии тех действий, которые имеют отношение к цели. Однако, при таком подходе возникает следующая проблема: применять ли действия, связанные с целью, немедленно, как только они найдены или же приостановить применение действия до тех пор, пока не будут найдены все действия имеющие отношение к цели? STRIPS применяет действия не откладывая, достигая каждой цели по отдельности.
	
	МакДермот показал, что эффективность планирования с использованием метода анализа средств и целей может быть намного повышена задержкой применения действия до тех пор, пока не будут найдены все релевантные (относящиеся к цели действия) и повторением поиска релевантных действий заново, после каждого применения действия.	Для решения проблемы фрейма STRIPS предлагает в состоянии, к которому применяется правило (действие), изменять выполнимость лишь тех формул, которые описаны в эффекте действия, а выполнимость всех остальных оставлять неизменной.
	
	Рассмотрим постановку задачи планирования при классических допущениях в терминах STRIPS.	Как и выше, фактом будем называть замкнутую атомарную формулу языка исчисления предикатов 1-го порядка (ИПП), а состоянием "--- некоторое множество фактов. Неформально, состояние представляет модель среды, в которой действует  интеллектуальный агент.
	Приведём пример описания среды в терминах STRIPS:
	
	\[
		s = \{ATR(a), AT(B,b), AT(C,c), \forall u\forall x\forall y ((AT(u,x) \wedge (x \not= y)) \rightarrow \neg AT(u,y))\}.
	\]
	Здесь, $ATR(a)$ означает, что <<робот находится в комнате $a$>>, $AT(B,b)$ "--- <<ящик $B$ находится в комнате $b$>>, $AT(C,c)$ "--- <<ящик $C$ находится в комнате $c$>>. Имена конкретных объектов из этого множества: $a$, $b$, $c$ "--- соответственно <<комната $a$>>, <<комната $b$>>, <<комната $c$>>; $A$, $B$, $C$ "--- соответственно, <<ящик $A$>>, <<ящик $B$>>, <<ящик $C$>>.
	
	Действия агента будем описывать с помощью правил, при этом, для упрощения таких описаний, примем некоторые соглашения. При описании STRIPS-задачи планирования как в множествах добавляемых, так и в множествах удаляемых фактов будем использовать  лишь атомарные формулы без функциональных символов. Пример правила:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{l c}
			Имя правила: & $Push(x, y, z)$\\
			Условие: & $C(R) = \{ATR (y), AT(x, y)\}$\\
			Список добавлений: & $A(R) = \{ATR (y), AT(x, y)\}$\\
			Список удалений: & $D(R) = \{ATR (z), AT(x, z)\}$
		\end{tabular}
	\end{table}
	
	В приведённом примере STRIPS-правило $Push(x, y, z)$ описывает действие робота по перемещению ящика $x$ из комнаты $y$ в комнату $z$. Здесь, $x$, $y$, $z$ "--- переменные. Выполнение агентом действия сводится к применению правила. Применение правила $R$ преобразует состояние $s$ в $s'$ следующим образом:
	
	\[
		s' = (s \setminus (D(R)\theta)) \cup (A(R)\theta)).
	\]
	Это преобразование обозначается так: $s \overset{R,\theta}{\Rightarrow} s'$, где через $\theta$ обозначена подстановка элементов предметной области вместо переменных.
	
	\begin{Def}[STRIPS-допущение]
		При применении некоторого правила $R$ к состоянию $s$ выполнимость факта $f\in s$ изменяется, только если факт $f$ описан либо в списке удалений $D(R)$, либо в списке добавлений $A(R)$.
	\end{Def}
	
	Технически, при проверке применимости некоторого правила $R$, STRIPS выполняет полную подстановку на места всех переменных индивидов предметной области. Возможны различные варианты подстановок. Некоторые варианты подстановки могут давать примеры правил, применимых (или же неприменимых) в состоянии $s$. Однако, в алгоритм STRIPS можно внести незначительные модификации для применения не полностью означенных правил. В этом случае, в состоянии $s$ появились бы факты с переменными в описании. Как будет видно далее, неполная подстановка активно используется планировщиками в пространстве планов. Соответствующее свойство этих планировщиков получило название \textit{малого связывания} (least commitment).
	
	Приведем постановку задачи STRIPS-планирования.
	
	\begin{Def}
		Будем называть доменом планирования $P = \langle s_0, \Sigma R\rangle$, где $s_0$ "--- начальное состояние, $\Sigma R$ "--- конечное множество правил.
	\end{Def}
	\begin{Def}
		Будем называть задачей планирования $T = \langle P, G\rangle$, где $G$ "--- описание целевого факта агента, или просто цель.
	\end{Def}

	Решение задачи планирования $T$ заключается в нахождении плана, который достигает цели $G$.
	\begin{Def}
		План $Plan$ "--- это последовательность состояний $s_0,\dots,s_n$, последовательность правил $R_1,\dots,R_n$ и последовательность подстановок $\theta_1,\dots,\theta_n$, такая что, $G$ выполнима в $s_n$. Длина плана $Plan$ равна $n$:
		\[
			Plan: s_0 \overset{R_1,\theta_1}{\Rightarrow} s_1 \overset{R_2,\theta_2}{\Rightarrow} s_2 \dots \overset{R_n,\theta_n}{\Rightarrow} s_n.
		\]
	\end{Def}
	
	На вход алгоритма STRIPS подаётся множество правил $\Sigma R$, начальное состояние $s_0$, цель $G$.
	
	\begin{algorithm}[H]
		\caption{Алгоритм STRIPS}\label{alg:strips}
		\begin{algorithmic}[1]
			\Require $\Sigma R$, $s$, $G$
			\Ensure $Plan$
			
			\State $s=s_0$
			\While $G$ не выполнимо в $s$
				\State выбрать компоненту $g$ из $G$ \label{alg_st:goal}
				\State выбрать правило $R\in\Sigma R$ такое, что $g\in A(R)$ \label{alg_st:act}
				\State \Call{STRIPS}{$\Sigma R$,$s$,$C(R)$}
				\State применить $R$ к $s$ \label{alg_st:app}
				\State добавить $R$ в $Plan$
			\EndWhile
			
			\Return $Plan$
		\end{algorithmic}
	\end{algorithm}

	Будем полагать, что в множестве $\Sigma R$ все правила полностью конкретизированы. Вначале в стек целей помещается главная цель $G$. Если цель не является простой, т.~е. содержит конъюнкцию литералов, то система STRIPS добавляет в стек в некотором порядке каждый из литералов составной цели (шаг \autoref{alg_st:goal}). Когда верхняя цель стека является однолитеральной, система ищет действие (шаг \autoref{alg_st:act}), которое содержит в списке добавлений литерал, сопоставимый с этой целью. Если такое действие не применимо к текущему состоянию, тогда его предусловие помещается в стек целей, иначе действие применяется к текущему состоянию (шаг \autoref{alg_st:app}) и помещается в план $Plan$. Если верхняя цель в стеке соответствует текущему состоянию, то она удаляется из стека. Алгоритм STRIPS завершается, когда стек пуст.
	
	Существуют задачи, для которых STRIPS либо не может построить план, либо находит не минимальный план. Причина этого кроется в том, что STRIPS удовлетворяет каждую компоненту составной цели по отдельности, без учёта их взаимосвязи. Особенность предметной области, где цели взаимосвязаны (взаимодействуют) получила название взаимосвязи целей.
	
	\printbibliography
\end{document}