\documentclass[mathserif]{beamer}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{theorems}[numbered]
\usetheme{AnnArbor}
\usecolortheme{crane}


\usepackage{cmap}	% Поддержка поиска русских слов в PDF (pdflatex)
\usepackage[T2A]{fontenc}       %поддержка кириллицы
\usepackage[cp1251]{inputenc}	% Выбор языка и кодировки
\usepackage[english, russian]{babel}
\usepackage{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{subfig}

\graphicspath{{../../images/}} 			% Пути к изображениям

\DeclareMathOperator*{\argmax}{arg\,max}
\algnewcommand\And{\textbf{and}}
\makeatletter
\newenvironment<>{proofs}[1][\proofname]{%
	\par
	\def\insertproofname{#1\@addpunct{.}}%
	\usebeamertemplate{proof begin}#2}
{\usebeamertemplate{proof end}}
\makeatother

\makeatletter
\newenvironment{cenumerate}{%
	\enumerate
	\setcounter{\@enumctr}{\csname saved@\@enumctr\endcsname}%
}{%
\expandafter\xdef\csname saved@\@enumctr\endcsname{\the\value{\@enumctr}}%
\endenumerate
}
\newenvironment{cenumerate*}{%
	\enumerate
}{%
\expandafter\xdef\csname saved@\@enumctr\endcsname{\the\value{\@enumctr}}%
\endenumerate
}
\makeatother

\let\Theorem\relax
\newtheorem{Theorem}{Теорема}
\newtheorem{Pred}{Утверждение}
\let\Corollary\relax
\newtheorem{Corollary}{Следствие}
\newtheorem{Def}{Определение}
\floatname{algorithm}{Алгоритм}
\algrenewcommand\algorithmicrequire{\textbf{Вход:}}
\algrenewcommand\algorithmicensure{\textbf{Выход:}}
\algrenewcommand\algorithmicreturn{\textbf{Выход:}}

\begin{document}
	
	\title[Элементы картины мира]{Исследование образной и процедурной компонент элементов картины мира субъекта деятельности}
	\author{Александр Панов}
	\institute[ИСА РАН]{ИСА РАН\\ научный руководитель д.ф.-м.н., проф. Г.\,С.~Осипов}
	\date{10 декабря 2014 г.} 
	
	\begin{frame}
		\titlepage
	\end{frame}

	\begin{frame}
		\frametitle{Картина мира и нейрофизиология}

		\begin{figure}
			\includegraphics[width=0.33\textwidth]{ivanitsky_cyrcle}
		\end{figure}
		
		По нейрофизиологическим данным (В. Маунткасл,1981; Дж. Хокинс, 2009), в том числе в \textit{теории повторного входа} или \textit{информационного синтеза} (Д.~Эдельман, 1981; А.\,М.~Иваницкий, 1996) возникновение ощущения, т.~е. активизация некоторого элемента картины мира субъекта, происходит при замыкании контура распространения нервного возбуждения от сенсорного входа. При этом происходит наложение значения сигнала (гиппокамп) и эмоционального отношения к нему (гипоталамус) на поступившую сенсорную информацию.
	\end{frame}

	\begin{frame}
		\frametitle{Картина мира и психология}
		
		В \textit{культурно"--~историческом подходе} (А.\,Р.~Лурия, 1970; Л.\,Н.~Выготский, 1960) вводится понятие знака как основного инструмента познавательной деятельности субъекта. В \textit{теории деятельности} (А.\,Н.~Леонтьев, 1975) раскрывается структура знака и его роль в формировании не только познавательной, но и любой другой деятельности субъекта.
		\par\bigskip
		По Леонтьеву образующими картины мира, т.~е. компонентами знака, являются \textit{образ}, \textit{значение} и \textit{личностный смысл}.<<В значениях представлена преобразованная и свёрнутая в материи языка идеальная форма существования предметного мира ... раскрываемая в совокупной общественной практикой>>. Личностный смысл является <<значением"--~для"--~меня>>.
		\par\bigskip
		<<Движение,~соединяющее абстрактное значение с чувственным миром,~представляет собой одно из существеннейших движений сознания>> (А.\,Н.~Леонтьев).
	\end{frame}
	
	\begin{frame}
		\frametitle{Знак "--- элемент картины мира}
		\begin{columns}
			\begin{column}{0.6\textwidth}
				\begin{figure}
					\includegraphics[width=0.7\textwidth]{sign}
				\end{figure}
			\end{column}
			\begin{column}{0.4\textwidth}
				Знак имеет следующие компоненты: 
				\begin{itemize}
					\item имя,
					\item образ, 
					\item значение и 
					\item личностный смысл.	
				\end{itemize}
			\end{column}
		\end{columns}						

	\end{frame}	
				
	\begin{frame}
		\frametitle{Предмет и цель исследования}
		
		\textbf{Предмет исследования} "--- построение моделей картины мира субъекта деятельности и некоторых когнитивных функций.
		\par\bigskip
		\textbf{Целью исследования} является разработка моделей и алгоритмов формирования пары образа и значения элемента знаковой картины мира субъекта деятельности.

		\par\bigskip
		Таким образом, в настоящей работе рассматриваются алгоритмы формирования двух основных компонент знака: образа и значения. Исследуется сходимость итерационного процесса связывания этих компонент и рассматриваются некоторые функции знаковой картины мира
	\end{frame}
	
	\begin{frame}
		\frametitle{Формальная постановка задачи}
		В качестве модели компонент знака в работе строится специальный $R$-автомат, функционирование которого с некоторыми упрощениями соответствует нейрофизиологическим данным о работе указанных участков коры головного мозга человека.
		\par\bigskip
		В работе были поставлены следующие задачи:
		\begin{itemize}
			\item исследовать автоматную функцию иерархии $R$-автоматов с заданным множеством состояний, т.~е. со сформированными матрицами предсказания после завершения процесса обучения (например, по алгоритму HTM);
			\item на основе построенной модели разработать итерационный алгоритм формирования и связывания двух основных компонент знака: образа и значения;
			\item исследовать сходимость построенного итерационного алгоритма под управлением значения, полученного из внешней среды.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Признаки и распознающие автоматы}
		Пусть заданы следующие множества:
		\begin{itemize}
			\item 
			$\mathcal R$ "--- совокупность распознающих автоматов или $R$-автоматов,
			\item
			$\mathcal F$ "--- совокупность допустимых признаков.
		\end{itemize}
		\par\bigskip
		Введём бинарное отношение $\dashv$, определённое на декартовом произведении $\mathcal F\times\mathcal R$, и будем читать $f_k{\dashv}R_i^j$ как <<признак $f_k$ распознаётся $R$-автоматом $R_i^j$>>. 
		\par\bigskip	
		Множество всех распознаваемых $R$-автоматом $R_i^j$ признаков будем обозначать $F_i^{*j}$, т.~е. ${\forall}f^*{\in}F_i^{*j} f^*{\dashv}R_i^j, F_i^{*j}{\subseteq}\mathcal F$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Иерархия распознающих автоматов}
		\begin{figure}
			\includegraphics[width=0.5\textwidth]{rb_hierarchy}
		\end{figure}
		Рассмотрим связный ориентированный ярусный граф $G_R=(V,E)$:
		\begin{itemize}
			\item 
			$V=\mathcal R$ "--- множество вершин,
			\item
			$E\subset \mathcal R\times\mathcal R$ "--- множество рёбер,
			\item 
			каждая вершина, принадлежащая $j$-ому ярусу графа $G_R$, является $R$-автоматом $R_i^j$ уровня $j$,
			\item
			каждое ребро $e=(R_{i_1}^{j_1},R_{i_2}^{j_2}){\in}E$ обозначает иерархическую связь между дочерним $R$-автоматом $R_{i_1}^{j_1}$ и $R$-автоматом "--- родителем $R_{i_2}^{j_2}$.				
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Входные признаки и функции распознавания}
		Введём следующие определения.
		\begin{itemize}
			\item 
			Признак $f\dashv R_k^{j-1}$ называется входным для $R$-автомата $R_i^j$, если $R_k^{j-1}$ является дочерним автоматом по отношению к $R_i^j$. Всё множество входных признаков для $R_i^j$ будем обозначать $F_i^j$.
			\item
			Для каждого признака $f^*{\in}F_i^{*j}$ введём \textit{функцию распознавания} $\hat{f}(x_1,\dots,x_q)=x^*$, где $x^*{\in}(0,1)$ "--- вес распознаваемого признака $f^*$, а $x_1,\dots,x_q{\in}(0,1)$ "--- веса признаков из множества входных признаков $F_i^j$. Всю совокупность функций распознавания для $R_i^j$ будем обозначать $\hat{F}_i^j$.
		\end{itemize}
	\end{frame}
	
	\begin{frame}[t]
		\frametitle{Структура распознающего автомата}

		\vspace*{-0.5cm}
		\begin{minipage}[t]{\textwidth}
			\begin{figure}[t]
				\includegraphics[width=\textwidth]{rb_cycle}
			\end{figure}
		\end{minipage}

		\begin{itemize}
			\item вектор $\bar{x}_i^j(t)$ длины $l_i^j$ "--- входной сигнал (вектор весов входных признаков), 
			\item вектор $\bar{x}_i^{*j}(t)$ длины $l_i^j$ "--- выходной сигнал (вектор весов распознаваемых признаков), 
			\item вектор $\hat{x}_i^{j+1}(t)$ длины $q_i^{j+1}$ "--- управляющий вектор, задающий начальное состояние в моменты времени $0,h_i^j,2h_i^j,\dots$,
			\item вектор $\hat{x}_i^j(t)$ длины $q_i^j$ "--- вектор состояния (вектор ожиданий входных признаков в следующий момент времени),
			\item $h_i^j$ "--- глубина памяти $R$-автомата $R_i^j$.
		\end{itemize}

	\end{frame}
	
	
	\begin{frame}
		\frametitle{Входы и выходы распознающего автомата}
		
		\begin{minipage}[t]{\textwidth}
			\begin{figure}[t]
				\includegraphics[width=\textwidth]{rb_io}
			\end{figure}
		\end{minipage}
	\end{frame}

	\begin{frame}
		\frametitle{Матрица предсказаний}	
		Для определения состояния $R$-автомата и его автоматной функции, поставим каждой функции распознавания $\hat{f}_k$ из множества $\hat{F}_i^j$ в соответствие набор булевых матриц предсказания $Z_k=\{Z_1^k,…,Z_m^k\}$ размерности $q_i^j\times h_i^j$. Тогда
		\begin{itemize}
			\item столбец $\bar{z}_u^r=(z_{u1}^k,…,z_{uq}^k)$ матрицы $Z_r^k$ "--- это вектор предсказания входных признаков из множества $F_i^j$ в момент времени $\tau_s+u$, $z_{uv}^k\in\{0,1\}$,
			\item матрица $Z_r^k$ задаёт последовательность битовых векторов, наличие бита в котором свидетельствует о присутствии распознаваемого функцией $\hat{f}_k$ признака,
			\item $\mathcal{Z}_i^j$ "--- множество всех матриц предсказания $R$-автомата $R_i^j$.
		\end{itemize}
	\end{frame}	
		
	\begin{frame}
		\frametitle{Входные и выходные функции}	
		Таким образом, $R$-автомат $R_i^j$ является бесконечным автоматом Миля с переменной структурой и конечной памятью и определяется следующим набором $R_i^j=<X_i^j\times \hat{X}_i^{j+1}, 2^{\mathcal Z_i^j}, X_i^{*j}\times \hat{X}_i^j,\varphi_i^j,\vec\eta_i^j,>$, где
		\begin{itemize}
			\item $X_i^j$ "--- множество входных сигналов, 
			\item $X_i^{*j}$ "--- множество выходных сигналов, 
			\item $\hat{X}_i^{j+1}$ "--- множество управляющих сигналов с верхнего уровня иерархии,
			\item $\hat{X}_i^j$ "--- множество управляющих сигналов на нижний уровень иерархии,
			\item $2^{\mathcal Z_i^j}$ "--- множество состояний (множество подмножеств множества матриц предсказания),
			\item $\varphi_i^j:X_i^j\times \hat{X}_i^{j+1}\to 2^{\mathcal Z_i^j}$ "--- функция переходов,
			\item $\vec\eta_i^j:2^{\mathcal Z_i^j} \to X_i^{*j}\times \hat{X}_i^j$ "--- вектор"--~функция выходов.
		\end{itemize}
	\end{frame}	
	
	\begin{frame}
		\frametitle{Алгоритм $\mathfrak A_{th}$ функционирования $R$-автомата}
				
		\par\bigskip
		Разработан пороговый алгоритм $\mathfrak A_{th}(c_1,c_2)$ вычисления функции переходов $\varphi_i^j$ и выходной функции $\vec\eta_i^j$ по начальному моменту времени $\tau_s$, управляющему воздействию $\hat x_i^{j+1}(\tau_s)$ и входному воздействию $\omega_i^j$. 
		
		\par\bigskip
		Для исследования автоматной функции на основании построенного алгоритма ниже будут построены 4 типа операторов распознавания, сформулированы задачи классификации и доказаны теоремы корректности линейных замыканий множеств этих операторов.
	\end{frame}

	\begin{frame}
		\frametitle{Статический оператор распознавания}
		Зафиксируем момент времени $t$, равный началу некоторого $s$-го вычислительного цикла $\tau_s$, т.~е. рассмотрим первый этап алгоритма $\mathfrak A_{th}$ "--- задание начального состояния $R$-автомата.
		\par\bigskip
		В этом случае, $R$-автомат $R_i^j$ можно рассматривать как статический оператор распознавания $R_i^j(\hat{x}_i^{j+1},\mathcal{Z}_i^j,\bar{x}_i^j)=\bar{x}_i^{*j}$.
	\end{frame}
		
	\begin{frame}
		\frametitle{Задача классификации}
		Пусть
		\begin{itemize}
			\item $\{Q\}$ "--- совокупность задач классификации,
			\item $\{\mathcal{A}\}$ "--- множество алгоритмов, переводящих пары $(\hat{x},\bar{x})$ в вектора $\bar{\beta}$, составленные из элементов $0,1,\Delta:\mathcal{A}(\hat{x},\bar{x})=\bar{\beta}$.
		\end{itemize}
		\par\bigskip
		\begin{columns}
			\begin{column}{0.5\textwidth}
				Задача $Q(\hat{x},\bar{x},\alpha_1,\dots,\alpha_l)\in\{Q\}$ состоит в построении алгоритма, вычисляющего по поступившему вектору ожиданий $\hat{x}$ и входному вектору $\bar{x}$ значения $\alpha_1,\dots,\alpha_l\in\{0,1\}$ присутствия признаков $f_1^*,…,f_l^*$. 
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=1]{rb_correct}
				\end{figure}
			\end{column}	
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство корректности алгоритма}
		\begin{Def}
			Алгоритм $\mathcal{A}$ называется корректным для задачи $Q$, если выполнено равенство
			$$
			\mathcal{A}(\hat{x},\bar{x})=\bar{\alpha}.
			$$
			Алгоритм $\mathcal{A}$, не являющийся корректным для $Q$, называется некорректным.
		\end{Def}
		\par\bigskip		
		Далее будем считать, что множество $\{\mathcal{A}\}$ является совокупностью, вообще говоря, некорректных алгоритмов.
	\end{frame}
	
	\begin{frame}
		\frametitle{Разложение алгоритма классификации}
		\begin{Pred}[аналог теоремы Журавлёва о введении пространства оценок]\label{st:decompositon}
			Каждый алгоритм $\mathcal{A}\in\{\mathcal{A}\}$ представим как последовательность выполнения алгоритмов $R$ и $C$, где $R(\hat{x},\bar{x})=\bar{x}^*$, $\bar{x}^*$ "--- вектор действительных чисел, $C(\bar{x}^*)=\bar{\beta}$, $\beta_i\in\{0,1,\Delta\}$.
		\end{Pred}
		\par\bigskip
		\begin{itemize}
			\item $R$ "--- оператор распознавания,
			\item $C$ "--- решающее правило.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Решающее правило и операции над алгоритмами}
		\begin{Def}
			Решающее правило $C^*$ называется корректным на множестве входных векторов $X$, если для всякого вектора $\bar{x}$ из $X$ существует хотя бы один числовой вектор $\bar{x}^*$ такой, что $C^*(\bar{x}^*)=\bar{\alpha}$, где $\bar{\alpha}$ "--- информационный вектор входного вектора $\bar{x}$.
		\end{Def}
		В множестве операторов $\{R\}$ введём операции умножения на скаляр, сложения и умножения. Пусть $r'$ "--- скаляр, $R',R''\in\{R\}$. Определим операторы $r'{\cdot}R'$, $R'+R''$ и $R{\cdot}R''$ следующим образом:
		\begin{equation}
			\label{eq:oper_scalar}
			r'{\cdot}R'=(r'{\cdot}{x_1^*}',\dots,r'{\cdot}{x_l^*}'),
		\end{equation}
		\begin{equation}
			\label{eq:oper_sum}
			R'+R''=({x_1^*}'+{x_1^*}'',\dots,{x_1^*}'+{x_l^*}''),
		\end{equation}
		\begin{equation}
			\label{eq:oper_mult}
			R'{\cdot}R''=({x_1^*}'{\cdot}{x_1^*}'',\dots,{x_1^*}'{\cdot}{x_l^*}'').
		\end{equation}
	\end{frame}
	
	\begin{frame}
		\frametitle{Замыкание множества алгоритмов}
		\begin{Pred}
			Замыкание $L\{R\}$ множества $\{R\}$ относительно операций \eqref{eq:oper_scalar} и \eqref{eq:oper_sum} является векторным пространством.
		\end{Pred}
		\begin{Pred}
			Замыкание $\mathfrak{U}\{R\}$ множества $\{R\}$ относительно операций \eqref{eq:oper_scalar}, \eqref{eq:oper_sum} и \eqref{eq:oper_mult} является ассоциативной линейной алгеброй с коммутативным умножением.
		\end{Pred}
		\begin{Def}
			Множества $L\{A\}$ и $\mathfrak{U}\{A\}$ алгоритмов $\mathcal{A}=R{\cdot}C^*$ соответственно таких, что $R{\in}L\{R\}$ и $R\in\mathfrak{U}\{R\}$, соответственно называются линейными и алгебраическими замыканиями множества $\{\mathcal{A}\}$.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство полноты задачи}
		Зафиксируем пару $(\hat{x},\bar{x})$ управляющего вектора и входного вектора. Будем рассматривать задачи $Q(\hat{x},\bar{x})$, обладающие следующим свойством относительно множества операторов распознавания $\mathcal{R}$.
		
		\begin{Def}
			Если множество векторов $\{R(\hat{x},\bar{x})\}$, где $R$ пробегает некоторое множество операторов распознавания $\mathcal{R}$, содержит базис в пространстве числовых векторов длины $l$, то задача $Q(\hat{x},\bar{x},\bar{\alpha})$ называется полной относительно $\mathcal{R}$.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Связь свойств полноты и корректности}
		\begin{Pred}[аналог теоремы Журавлёва о корректности линейного замыкания]\label{st:correctness}
			Если множество задач $\{Q\}$ состоит лишь из задач, полных относительно $\mathfrak{R}$, то линейное замыкание $L\{R{\cdot}C^*\}$ ($C^*$ "--- произвольное фиксированное корректное решающее правило, $R$ пробегает множество $\mathcal{R}$) является корректным относительно $\{Q\}$.
		\end{Pred}
	\end{frame}
	
	\begin{frame}
		\frametitle{Основная теорема корректности в статическом случае}
		Будем рассматривать только такие задачи $Q(\hat{x},\bar{x},\bar{\alpha})$, для которых удовлетворяется следующее условие: ${\exists}k$ такое, что $x_k$ является $k$-ым элементом вектора $\bar{x}$ и $x_k>1/2$. 
		\par\bigskip
		В работе доказано следующее утверждение.
		\begin{Theorem}
			\label{th:correctness}
			Линейное замыкание $L\{\mathcal{A}\}$ семейства алгоритмов $\{\mathcal{A}\}=\{R{\cdot}C^*\}$ с произвольным корректным решающим правилом $C^*$ и операторами распознавания $R$, определёнными алгоритмом $\mathfrak{A}_{th}$, является корректным на $\{Q\}$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Операторы распознавания $R^t$}
		Пусть $\tau_s<t<\tau_s+h_i^j$, тогда операторы распознавания примут вид $R_i^j(\hat{x}_i^j(t), \mathcal{Z}_i^j, \bar{x}_i^j(t))$, кратко $R^t$. 
		\par\bigskip
		\begin{columns}
			\begin{column}{0.5\textwidth}		
				Для этих операторов постановка задачи распознавания выглядит таким же образом как и для операторов $R$, формулировки определений полноты и корректности идентичны. 
				\par\bigskip
				Теорема о корректности линейного замыкания $L\{R^t\cdot{C^*}\}$ доказывается аналогично.
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=2]{rb_correct}
				\end{figure}
			\end{column}			
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Динамические операторы распознавания}
		Будем фиксировать не конкретный момент времени $t$, а полуинтервал ${\Delta}t=[\tau_s,\tau_s+h_i^j)$. 
		\par\bigskip
		\begin{columns}
			\begin{column}{0.5\textwidth}
				В этом случае $R$-автомат $R_i^j$ можно рассматривать как \textit{динамический оператор распознавания} $\hat{R}_i^j(\hat{x}_i^{j+1}(\tau_s), \mathcal{Z}_i^j, \omega_{i\Delta{t}}^j)=\gamma_{i\Delta{t}}^j$
				\begin{itemize}
					\item принимающий  функцию входного воздействия $\omega_i^j$ и 
					\item выдающий функцию выходной величины $\gamma_i^j$. 
				\end{itemize}
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=1.0\linewidth,page=3]{rb_correct}
				\end{figure}
			\end{column}
		\end{columns}
	\end{frame}
	
	\begin{frame}
		\frametitle{Динамические операторы распознавания}
		Действие динамического оператора $\hat{R}_i^j$ можно заменить последовательным действием статических операторов 
		$$
		R(\hat{x}_i^{j+1}(\tau_s), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s)), R^1(\hat{x}_i^j(\tau_s+1), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s+1)), \dots,
		$$
		$$
		R^{h_i^j-1}(\hat{x}_i^j(\tau_s+h_i^j-1), \mathcal{Z}_i^j, \bar{x}_i^j(\tau_s+h_i^j-1)),
		$$
		выдающих последовательность 
		$$
		\{\bar{x}_i^{*j}(t)\}=\{\bar{x}_i^{*j}(\tau_s), \bar{x}_i^{*j}(\tau_s+1), \dots, \bar{x}_i^{*j}(\tau_s+h_i^j-1)\}.
		$$
		Так как параметр $h_i^j$ фиксирован, то конечные последовательности векторов  $\omega_{i\Delta{t}}^j$ и $\gamma_{i\Delta{t}}^j$ можно считать матрицами размерности $l_i^j\times{h_i^j}$. Далее будем опускать индексы $i$ и $j$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Задача классификации}
		Задача $\hat{Q}(\hat{x}, \omega_{{\Delta}t}, \bar{\alpha})$ состоит в построении алгоритма $\hat{\mathcal{A}}$, вычисляющего по поступившему начальному (управляющему) вектору ожиданий $\hat{x}$ и матрице входных воздействий $\omega_{{\Delta}t}$  последовательность векторов $\beta_{\Delta{t}}$, монотонно сходящуюся к информационному вектору $\bar{\alpha}$. 
		\par\bigskip
		Искомый оператор распознавания $\hat{R}$ должен выдавать весовую матрицу распознаваемых признаков $\gamma_{\Delta{t}}$, столбцы которой должны сходиться (с учётом корректного решающего правила) к информационному вектору: $\lim_{t\to\tau_s+h}\bar{x}^*(t)=\bar{\alpha}$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство корректность алгоритма}
		\begin{Def}
			Алгоритм $\hat{\mathcal{A}}(\hat{x},\bar{x})=\beta_{\Delta{t}}=(\bar{\beta}_1,\dots,\bar{\beta}_h)$ называется корректным для задачи $\hat{Q}$, если выполнено условие
			$$
			\|\bar{\beta}_1-\bar{\alpha}\|\geqslant\|\bar{\beta}_2-\bar{\alpha}\|\geqslant\dots\geqslant\|\bar{\beta}_h-\bar{\alpha}\|,
			$$
			причём $\|\bar{\beta}_h-\bar{\alpha}\|=0$. $\|\bar{\beta}_i-\bar{\alpha}\|=\sum_j{(\beta_{ij}-\alpha_j)}$, где $\beta_{ij}-\alpha_j=0$, если $\beta_{ij}=\alpha_j$, $\beta_{ij}-\alpha_j=\frac{1}{2}$, если $\beta_{ij}=\Delta$, и $\beta_{ij}-\alpha_j=0$ иначе. Алгоритм $\hat{\mathcal{A}}$, не являющийся корректным для $\hat{Q}$, называется некорректным.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Разложимость алгоритма}
		\begin{Pred}\label{st:decompositon_dyn}
			Каждый алгоритм $\hat{\mathcal{A}}\in\{\hat{\mathcal{A}}\}$ представим как последовательность выполнения алгоритмов $\hat{R}$ и $\hat{C}$, где $\hat{R}(\hat{x}, \mathcal{Z}, \omega_{\Delta{t}})=\gamma_{\Delta{t}}$, $\gamma_{\Delta{t}}$ "--- матрица действительных чисел, $\hat{C}(\gamma_{\Delta{t}})=\beta_{\Delta{t}}$, $\beta_{\Delta{t}}$ "--- матрица значений $\beta_{ij}\in\{0,1,\Delta\}$.
		\end{Pred}
	\end{frame}
	
	\begin{frame}
		\frametitle{Корректное решающее правило}
		Корректное решающее правило $\hat{C}^*$ для матрицы $\gamma_{\Delta{t}}$ определяется через набор корректных правил для векторов $(C_1^*, \dots, C_h^*)$ таких, что 
		$$
		\|C_1^*(\bar{x}^*(\tau_s))-\bar{\alpha}\|\geqslant\|C_2^*(\bar{x}^*(\tau_s+1))-\bar{\alpha}\|\geqslant\dots\geqslant
		$$
		$$
		\geqslant\|C_h^*(\bar{x}^*(\tau_s+h-1))-\bar{\alpha}\|,
		$$ 
		причём последняя норма равна нулю. В простейшем случае $\forall{i}$ $C_i^*(\bar{x}^*(\tau_s+i))=\bar{\alpha}$. 
		\par\bigskip
		Аналогично статическому случаю вводятся определения линейного $L\{\hat{R}\}$ и алгебраического $\mathfrak{U}\{\hat{R}\}$ замыкания над множеством $\{\hat{R}\}$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Основная теорема корректности в динамическом случае}
		Зафиксируем начальный вектора ожиданий $\hat{x}$ и последовательность входных векторов $\omega_{\Delta{t}}$. 
		\par\bigskip
		Если, как и в статическом случае, будем рассматривать только такие задачи $\hat{Q}(\hat{x},\omega_{\Delta{t}},\bar{\alpha})$, для которых в матрице $\omega_{\Delta{t}}$ в каждом столбце с номером $s$ ${\exists}k$ такое, что $x_{sk}$ является $k$-ым элементом вектора $\bar{x}(\tau_s+s)$ и $x_{sk}>1/2$, то можно сформулировать следующую теорему.
		\par\bigskip
		В работе доказано следующее утверждение.
		\begin{Theorem}\label{th:dyn_correct}
			Линейное замыкание $L\{\hat{\mathcal{A}}\}$ семейства алгоритмов $\{\hat{\mathcal{A}}\}=\{\hat{R}{\cdot}\hat{C}^*\}$ с произвольным корректным решающим правилом $\hat{C}^*$ и операторами распознавания $\hat{R}$, определёнными алгоритмом $\mathfrak{A}_{th}$, является корректным на $\{\hat{Q}\}$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Иерархический оператор распознавания}
		\begin{columns}
			\begin{column}{0.5\textwidth}
				Рассмотрим пример из двухуровневой иерархии, на каждом уровне которой находится по~одному оператору: статический $R_{i_1}^{j+1}(\hat x _{i_1}^{j+2},\bar x_{i_1}^{j+1}(\tau_s),\bar\alpha_{i_1}^{j+1})$ на верхнем уровне и динамический $\hat R_{i_2}^j(\hat x _{i_2}^{j+1},\omega_{i_2\Delta t}^j,\bar\alpha_{i_2}^j)$ "--- на нижнем.
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{figure}[t]
					\includegraphics[width=0.9\linewidth,page=4]{rb_correct}
				\end{figure}
			\end{column}
		\end{columns}
		
		\par\bigskip
		Данную иерархию можно рассматривать как \textit{иерархический оператор распознавания} $\hat R_{e,j}^2(\hat x_{i_1}^{j+1}(\tau_s),\mathcal Z_{i_1}^{j+1},\mathcal Z_{i_2}^j,\omega_{i_2\Delta t}^j)=\bar x_{i_1}^{*j+1}$.
	\end{frame}	
	
	\begin{frame}
		\frametitle{Задача классификации}
		Задача $\hat Q_{e,j}^2(\hat x_{i_1}^{j+2},\omega_{i_2\Delta t}^j,\bar\alpha_{i_1}^{j+1})$ состоит в построении алгоритма $\hat{\mathcal A_e}$, вычисляющего по поступившему начальному вектору ожиданий $\hat x_{i_1}^{j+2}$ и матрице входных воздействий $\omega_{i_2\Delta t}^j$ значения информационного вектора $\bar\alpha_{i_1}^{j+1}$.
	\end{frame}	
	
	\begin{frame}
		\frametitle{Основная теорема корректности в иерархическом случае}
		Зафиксируем начальный вектор ожиданий $\hat x_{i_1}^{j+2}$ и последовательность входных векторов $\omega_{i_2\Delta{t}}^j$. Если мы будем рассматривать только такие задачи $\hat Q_{e,j}^2(\hat x_{i_1}^{j+2},\omega_{i_2\Delta{t}}^j,\bar\alpha_{i_1}^{j+1})$, для которых в матрице $\omega_{i_2\Delta{t}}^j$ в каждом столбце с номером $s$ ${\exists}k$ такое, что $x_{sk}$ является $k$-ым элементом вектора $\bar x_{i_2}^j(\tau_s+s)$ и $x_{sk}>1/2$, то можно сформулировать следующую теорему.
		\par\bigskip
		В работе доказано следующее утверждение.
		\begin{Theorem}\label{th:hier_correct}
			Линейное замыкание $L\{\hat{\mathcal A_e}\}$ семейства алгоритмов $\{\hat{\mathcal A}_e\}=\{\hat R_{e,j}^2\cdot\hat C_e^*\}$ с произвольным корректным решающим правилом $\hat C_e^*$ и операторами распознавания $\hat R_{e,j}^2$, определёнными алгоритмом $\mathfrak A_{th}$, является корректным на~множестве задач $\{\hat Q_{e,j}^2\}$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Формирование пары <<образ "--- значение>>}
			Рассмотрим формирование пары <<образ "--- значение>> элемента картины мира субъекта под управлением эталонного значения, полученного из внешней среды.
	\end{frame}
	
	\begin{frame}
		\frametitle{Отношения иерархичности признаков}
		Введём семейство бинарных отношений $\{\sqsubset,\sqsubset^1,\sqsubset^2,\dots\}$, определённых на декартовом произведении $\mathcal F\times\mathcal F$. 
		\par\bigskip
		Признак $f_1$ является дочерним по отношению к признаку $f_2$: $(f_1,f_2 )\in\sqsubset$ или $f_1\sqsubset f_2$, в том случае, если $f_1\dashv R_1^j, f_2\dashv R_2^{j+1}$, $R_2^{j+1}$ "--- родительский $R$-автомат по отношению к $R_1^j$ и в множестве матриц предсказания $\mathcal Z_2$ признака $f_2$ существует как минимум одна матрица $Z_r^2$, содержащая некоторый столбец $\bar z_u^r$ с элементом $z_{uv}^r\not=0$, где $v$ "--- индекс признака $f_1$ во входном векторе для $R$-автомата $R_2^{j+1}$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Отношения иерархичности признаков}		
		Пара признаков $(f_1,f_2)\in\sqsubset^t$ или $f_1\sqsubset^t f_2$, где $t\in\{1,2,\dots\}$, если $f_1\dashv R_1^j, f_2\dashv R_2^{j+1}$, $R_2^{j+1}$ "--- родительский $R$-автомат по отношению к $R_1^j$ и в множестве матриц предсказания $\mathcal Z_2$ признака $f_2$ существует хотя бы одна матрица $Z_r^2$, содержащая $t$–ый столбец $\bar z_t^r$ с элементом $z_{tv}^r\not=0$, где $v$ "--- индекс признака $f_1$ во входном векторе для $R$-автомата $R_2^{j+1}$.
		\par\bigskip
		Каждый элемент вектора"--~столбца соответствует определённому признаку из входного множества признаков $R$-автомата, что означает задание типа для каждого элемента вектора-столбца. Будем обозначать тип $k$-го элемента вектора-столбца $R$-автомата $R_i^j$ как $f_i^j(k)\in F_i^j$, $k\in(1,q_i^j)$. 
	\end{frame}
	
	\begin{frame}
		\frametitle{Признаки <<условие>> и <<эффект>>}
		Для описания действий будем использовать правила, каждое из которых для простоты будем представлять в виде пары <<условия "--- эффект действия>>. Введём два выделенных признака: $f_c$ является меткой условия, а $f_e$ "--- меткой эффекта. Пусть некоторый $R$-автомат, например $R_0^1$, распознает оба эти признаки.
		\begin{Def}
			Те признаки, которые распознаются $R$-автоматами, выступающими родительскими по отношению к $R$-автомату $R_0^1$, будем называть процедурными признаками, остальные "--- объектными признаками.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Столбцы условий и эффектов}
		\begin{Def}
			Те столбцы матрицы предсказания $Z$, в которых соответствующий признаку $f_e$ элемент вектора не нулевой, будем называть столбцами эффектов, а те столбцы матрицы предсказания $Z$, в которых не равен нулю элемент вектора, соответствующий признаку $f_c$ -- столбцами условий. 
		\end{Def}
		\par\bigskip
		Пополним семейство отношений $\{\sqsubset,\sqsubset^1,\sqsubset^2,\dots\}$ двумя отношениями: $\sqsubset^c$ и $\sqsubset^e$, принадлежность к которым пары признаков $(f_1,f_2)$ свидетельствует о том, что признак $f_1$ присутствует соответственно в столбце условий и эффектов как минимум в одной матрице предсказания процедурного признака $f_2$.
	\end{frame}
	
	\begin{frame}
		\frametitle{Образ знака}
		\begin{Def}
			Если $f_1$ "--- признак, соответствующий знаку $s_1$, то подмножество $\tilde p(f_1)$ множества $\mathcal F$ таких признаков, что $\forall f_i\in\tilde p(f_1) f_i\sqsubset f_1$, будем называть образом знака $s_1$ (признака $f_1$).
		\end{Def}
		
		На множестве всех образов $\tilde P$ введём метрику $\rho_p(\tilde p(f_1),\tilde p(f_2))$, вычисляемую по следующему правилу:
		\begin{itemize}
			\item если $f_1$ и $f_2$ распознаются разными$R$-автоматами, т.е. $f_1\dashv R_1^j, f_2\dashv R_2^i$, то $\rho_p(\tilde p(f_1),\tilde p(f_2))=\infty$,
			\item если $f_1$ и $f_2$ распознаются одним и тем же $R$-автоматом $R_1^j$ со множеством входных признаков $F_1^j$ мощности $q$ и характерным временем $h$, то
			\begin{equation}
			\rho_p(\tilde p(f_1),\tilde p(f_2))=\min\limits_{\substack{Z_r^1\in Z_1\\Z_s^2\in Z_2}}\frac{1}{q\cdot h}\sum\limits_{u=1}^h\|\bar z_u^r-\bar z_u^s\|.
			\end{equation} 
		\end{itemize}
		
	\end{frame}
	
	\begin{frame}
		\frametitle{Значение знака}
		\begin{Def}
			Если $f_1$ "--- признак, соответствующий знаку $s_1$, $f_2$ "--- процедурный признак и $f_1\sqsubset^c f_2$, то будем называть $f_2$ значением знака $s_1$ (признака $f_1$). Множество всех значений признака $f_1$ будем обозначать $\tilde m(f_1)$.
		\end{Def}
		
		На множестве всех значений $\tilde M$ введём метрику $\rho_m(\tilde m(f_1),\tilde m(f_2))$ следующим образом:
		\begin{equation}
		\rho_m(\tilde m_1(f_1),\tilde m_2(f_2 ))=\min\limits_{\substack{f_i\in\tilde m(f_1 )\\f_j\in\tilde m(f_2 )}}\rho_p(\tilde p(f_i ),\tilde p(f_j )).
		\end{equation}
	\end{frame}
	
	\begin{frame}
		\frametitle{Матрица предсказаний процедурного признака}
		Матрицу предсказания $Z_r^p$ процедурного признака $f_p$ всегда можно представить в следующем виде:
		$$
		Z_r^p=(\bar z_1^{r,c},\dots,\bar z_{j_1}^{r,c},\bar z_{j_{1+1}}^{r,e},\dots,\bar z_{i_1}^{r,e},\dots,\dots,
		$$
		$$
		\bar z_{i_{k-1}+1}^{r,c},\dots,\bar z_{j_k}^{r,c},\bar z_{j_k+1}^{r,e},\dots,\bar z_{i_k}^{r,e}),
		$$
		где $\bar z_j^{r,c}$ "--- столбцы причин, $\bar z_i^{r,e}$ "--- столбцы следствий. 
		\par\bigskip
		Величину $k$ будем называть актностью процедурного признака. В дальнейшем будем рассматривать простые матрицы предсказаний $k$-актного процедурного признака:
		$$
		Z_r^p=(\bar z_1^{r,c},\bar z_2^{r,e},\dots,\dots,\bar z_{2\cdot k-1}^{r,c},\bar z_{2\cdot k}^{r,e}).
		$$
		\par\bigskip
		Краткая форма $k$-актного процедурного признака $f_p$ имеет матрицу предсказания, в которой оставлены только первый столбец условий и последний столбец эффектов.
	\end{frame}
	
	\begin{frame}
		\frametitle{Процедурный признак как правило}
		Любой элементарный процедурный признак $f_p$, распознаваемый $R$-автоматом $R_i^j$, можно представить в виде правила $r_p=<F_C(f_p),F_A(f_p),F_D(f_p)>$, в котором:
		\begin{itemize}
			\item $F_C (f_p )\subseteq F_i^j$ "--- множество признаков "--- условий правила: $\forall f\in F_C(f_p)$ $f\sqsubset^c f_p$;
			\item $F_A(f_p)\subseteq F_i^j$ "--- множество добавляемых правилом признаков: $\forall f\in F_A(f_p)$ $f\sqsubset^e f_p,f\notin F_C$;
			\item $F_D(f_p)\subseteq F_i^j$ "--- множество удаляемых правилом признаков: $\forall f\in F_D(f_p)$ $f\notin F_A,f\in F_C$.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство выполнимости}
		\begin{Def}
			Процедурный признак $f_p^1$ c матрицей предсказания $Z=(\bar z_1^c,\bar z_2^e)$ выполняется на векторе $z$ длины $q$, если $z\cdot \bar z_1^c=\bar z_1^c$.
		\end{Def}
		Будем говорить, что процедурный признак $f_p^1$ выполним в условиях процедурного признака $f_p^2$, если 
		\begin{itemize}
			\item оба признака распознаются одним и тем же $R$-автоматом $R_i^j$ и признак  $f_p^1$ выполняется на столбце условий матрицы предсказания признака $f_p^2$,
			\item $f_p^1\dashv R_1^{j_1}, f_p^2\dashv R_2^{j_2}$, множества $F_C(f_p^1 )$ и $F_C(f_p^2)$ состоят из одних и тех же признаков, образуемый вектор $\tilde z$ (той же мощности, что и множество $F_1^{j_1}$) элементы которого, соответствующие признакам из $F_C(f_p^2)$ принимаются равными $1$,  остальные "--- $0$, и признак $f_p^1$ выполним на векторе $\tilde z$. 
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Свойство конфликтности}
		\begin{Def}
			Будем говорить, что два процедурных признака $f_p^1$ и $f_p^2$ конфликтуют, если выполнено как минимум одно из следующих условий:
			\begin{itemize}
				\item $F_D(f_p^1)\cap F_A(f_p^2)\not=\varnothing$,
				\item $F_D(f_p^2)\cap F_A(f_p^1)\not=\varnothing$,
				\item $F_D(f_p^1)\cap F_C(f_p^2)\not=\varnothing$,
				\item $F_D(f_p^2)\cap F_C(f_p^1)\not=\varnothing$.
			\end{itemize}
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Операции приведения признаков}
		\begin{Def}
			Операцией сохраняющего приведения вектор-столбца $\bar z_1$ к множеству входных признаков $F_{i_2}^{j_2}$ будем называть такой вектор $\bar z_3$ длины $q_{i_2}^{j_2}$, элемент которого $z_{3k}=1$, если $f_{i_1}^{j_1}(k)=f_{i_2}^{j_2}(k)$ и $z_{1k}=1$, иначе $z_{3k}=0$, и обозначать $(\bar z_1\rightarrow F_{i_2}^{j_2})=\bar z_3$.
		\end{Def}
		
		\begin{Def}
			Операцией сужающего приведения вектор-столбца $\bar z_1$ к некоторому столбцу $\bar z_2$ $R$-автомата $R_{i_2}^{j_2}$ будем называть такой вектор $\bar z_3$ длины $q_{i_2}^{j_2}$, элемент которого $z_{3k}=1$, если $f_{i_1}^{j_1}(k)=f_{i_2}^{j_2}(k)$, $z_{2k}=1$ и $z_{1k}=1$, иначе $z_{3k}=0$, и обозначать $(\bar z_1\Rightarrow \bar z_2)=\bar z_3$.
		\end{Def}
	\end{frame}
	
	\begin{frame}
		\frametitle{Опыт наблюдения}
		У субъекта имеется опыт наблюдения, который выражается в виде отношения $\Psi_p^m$: $\tilde p\Psi_p^m \tilde m$, или $\Psi_p^m(\tilde p)=\tilde m$, в том случае, если $\tilde p\in\tilde P$ является образом некоторого знака $s$, а $\tilde m\in\tilde M$ -- значением того же знака $s$.
		\par\bigskip
		Разработан итерационный алгоритм $\mathfrak A_{pm}$ доопределения функции $\Psi_p^m$, который обеспечивает построение такого образа из множества признаков $\hat F$, при котором формируемое значение сходится к значению $\tilde m^0=\{f_p\}$, полученному из внешней среды.
	\end{frame}
	
	\begin{frame}
		\frametitle{Теорема корректности алгоритма $\mathfrak A_{pm}$}
		Имеет место следующее утверждение.
		\par\bigskip
		\begin{Theorem}
			Алгоритм $\mathfrak A_{pm}$ корректен, т.~е. последовательность значений $\langle\tilde m^{*(0)},\tilde m^{*(1)},\dots\rangle$, которая строится с помощью алгоритма $\mathfrak A_{pm}$ для  значения $\tilde m^0$, полученного из внешней среды, сходится к $\tilde m^0$.
		\end{Theorem}
	\end{frame}
	
	\begin{frame}
		\frametitle{Результаты}
		\begin{enumerate}
			\item Построена модель компонент знака "--- элемента картины мира субъекта деятельности.
			\item Построены четыре типа операторов распознавания (два статических случая, динамический и иерархический случаи) в терминах алгебраической теории для образной компоненты знака.
			\item Доказаны теоремы корректности линейных замыканий множеств построенных в работе операторов распознавания.
			\item Построен алгоритм итерационного процесса формирования и связывания двух компонент знака.
			\item Исследована сходимость итерационного процесса формирования и связывания двух компонент знака.
		\end{enumerate}
	\end{frame}
			
	\begin{frame}
		\centering
		\Huge
		Спасибо за внимание!
		\normalsize
		\par\bigskip
		\par\bigskip
		ИСА РАН, лаб. <<Динамические интеллектуальные системы>>, pan@isa.ru
	\end{frame}
\end{document}